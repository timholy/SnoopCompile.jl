<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Snooping on and fixing invalidations: @snoopr · SnoopCompile</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">SnoopCompile</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">SnoopCompile.jl</a></li><li><a class="tocitem" href="../tutorial/">Tutorial on the foundations</a></li><li><span class="tocitem">Modern tools</span><ul><li class="is-active"><a class="tocitem" href>Snooping on and fixing invalidations: <code>@snoopr</code></a><ul class="internal"><li><a class="tocitem" href="#Recording-invalidations"><span>Recording invalidations</span></a></li><li><a class="tocitem" href="#Analyzing-invalidations"><span>Analyzing invalidations</span></a></li><li><a class="tocitem" href="#Filtering-invalidations"><span>Filtering invalidations</span></a></li><li><a class="tocitem" href="#Fixing-invalidations"><span>Fixing invalidations</span></a></li></ul></li><li><a class="tocitem" href="../snoopi_deep/">Snooping on inference: <code>@snoopi_deep</code></a></li><li><a class="tocitem" href="../snoopi_deep_analysis/">Using <code>@snoopi_deep</code> results to improve inferrability and control specialization</a></li><li><a class="tocitem" href="../snoopi_deep_parcel/">Using <code>@snoopi_deep</code> results to generate precompile directives</a></li></ul></li><li><span class="tocitem">Older tools</span><ul><li><a class="tocitem" href="../snoopi/">Snooping on inference: <code>@snoopi</code></a></li><li><a class="tocitem" href="../snoopc/">Snooping on code generation: <code>@snoopc</code></a></li></ul></li><li><a class="tocitem" href="../userimg/">Creating <code>userimg.jl</code> files</a></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Modern tools</a></li><li class="is-active"><a href>Snooping on and fixing invalidations: <code>@snoopr</code></a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Snooping on and fixing invalidations: <code>@snoopr</code></a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/timholy/SnoopCompile.jl/blob/master/docs/src/snoopr.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="invalidations"><a class="docs-heading-anchor" href="#invalidations">Snooping on and fixing invalidations: <code>@snoopr</code></a><a id="invalidations-1"></a><a class="docs-heading-anchor-permalink" href="#invalidations" title="Permalink"></a></h1><div class="admonition is-compat"><header class="admonition-header">Compat</header><div class="admonition-body"><p><code>@snoopr</code> is available on <code>Julia 1.6.0-DEV.154</code> or above, but the results can be relevant for all Julia versions.</p></div></div><p>Invalidations occur when there is a danger that new methods would supersede older methods in previously-compiled code. For safety, Julia&#39;s compiler <em>invalidates</em> that old code, marking it as unsuitable for use; the next time you call that method, it will have to be compiled again from scratch. (If no one ever needs that method again, there is no major loss.)</p><p>Some packages define new methods that force invalidation of previously-compiled code. If your package, or any of your dependencies, triggers many invalidations, it has several bad effects:</p><ul><li>any invalidated methods you need for the functionality in your package will have to be recompiled. This will lead to a direct (and occasionally large) slowdown for your package.</li><li>invalidations by your dependencies (packages you rely on) can block precompilation of methods in your package, preventing you from taking advantage of some the other features of SnoopCompile.</li><li>even if you don&#39;t need the invalidated code for your package, any invalidations triggered by your package might harm packages that depend on yours.</li></ul><p>For these reasons, it&#39;s advisable to begin by analyzing invalidations. On recent Julia versions, most packages do not trigger a large number of invalidations; often, all that is needed is a quick glance at invalidations before moving on to the next step. Occasionally, checking for invalidations can save you a lot of confusion and frustration at later steps, so it is well worth taking a look.</p><p>Readers who want more background and context are encouraged to read <a href="https://julialang.org/blog/2020/08/invalidations/">this blog post</a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Invalidatons occur only for compiled code; method definitions themselves cannot be invalidated. As a consequence, it&#39;s possible to have latent invalidation risk; this risk can become exposed if you use some intermediate functionality before loading your package, or if your dependencies someday add <code>precompile</code> directives. So even if you&#39;ve checked for invalidations previously, sometimes it&#39;s worth taking a fresh look.</p></div></div><h2 id="Recording-invalidations"><a class="docs-heading-anchor" href="#Recording-invalidations">Recording invalidations</a><a id="Recording-invalidations-1"></a><a class="docs-heading-anchor-permalink" href="#Recording-invalidations" title="Permalink"></a></h2><p>To record the invalidations caused by defining new methods, use <code>@snoopr</code>. <code>@snoopr</code> is exported by SnoopCompile, but the recommended approach is to record invalidations using the minimalistic <code>SnoopCompileCore</code> package, and then load <code>SnoopCompile</code> to do the analysis:</p><pre><code class="language-julia">using SnoopCompileCore
invalidations = @snoopr begin
    # package loads and/or method definitions that might invalidate other code
end
using SnoopCompile   # now that we&#39;ve collected the data, load the complete package to analyze the results</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>SnoopCompileCore</code> was split out from <code>SnoopCompile</code> to reduce the risk of invalidations from loading <code>SnoopCompile</code> itself. Once a MethodInstance gets invalidated, it doesn&#39;t show up in future <code>@snoopr</code> results, so anything that gets invalidated in order to provide <code>@snoopr</code> would be omitted from the results. <code>SnoopCompileCore</code> is a very small package with no dependencies and which avoids extending any of Julia&#39;s own functions, so it cannot invalidate any other code.</p></div></div><h2 id="Analyzing-invalidations"><a class="docs-heading-anchor" href="#Analyzing-invalidations">Analyzing invalidations</a><a id="Analyzing-invalidations-1"></a><a class="docs-heading-anchor-permalink" href="#Analyzing-invalidations" title="Permalink"></a></h2><h3 id="A-first-example"><a class="docs-heading-anchor" href="#A-first-example">A first example</a><a id="A-first-example-1"></a><a class="docs-heading-anchor-permalink" href="#A-first-example" title="Permalink"></a></h3><p>We&#39;ll walk through this process with the following example:</p><pre><code class="language-julia-repl">julia&gt; f(::Real) = 1;

julia&gt; callf(container) = f(container[1]);

julia&gt; call2f(container) = callf(container);</code></pre><p>Because code doesn&#39;t get compiled until it gets run, and invalidations only affect compiled code, let&#39;s run this with three different container types:</p><pre><code class="language-julia-repl">julia&gt; c64  = [1.0]; c32 = [1.0f0]; cabs = AbstractFloat[1.0];  # Vector{Float64}, Vector{Float32}, and Vector{AbstractFloat}, respectively

julia&gt; call2f(c64)
1

julia&gt; call2f(c32)
1

julia&gt; call2f(cabs)
1</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>If you&#39;re following along, be sure you actually execute these methods, or you won&#39;t obtain the results below.</p></div></div><p>Now we&#39;ll define a new <code>f</code> method, one specialized for <code>Float64</code>. So we can see the consequences for the compiled code, we&#39;ll make this definition while snooping on the compiler with <code>@snoopr</code>:</p><pre><code class="language-julia-repl">julia&gt; using SnoopCompileCore

julia&gt; invalidations = @snoopr f(::Float64) = 2;</code></pre><p>As should be apparent, running <code>call2f</code> on <code>c64</code> should produce a different result than formerly, so Julia certainly needs to invalidate that code.  Let&#39;s see what that looks like. The simplest thing we can do is list or count invalidations:</p><pre><code class="language-julia-repl">julia&gt; using SnoopCompile

julia&gt; length(uinvalidated(invalidations))  # collect the unique MethodInstances &amp; count them
6</code></pre><p>The length of this set is your simplest insight into the extent of invalidations triggered by this method definition.</p><p>If you want to fix invalidations, it&#39;s crucial to know <em>why</em> certain MethodInstances were invalidated. For that, it&#39;s best to use a tree structure, in which children are invalidated because their parents get invalidated:</p><pre><code class="language-julia-repl">julia&gt; trees = invalidation_trees(invalidations)
1-element Vector{SnoopCompile.MethodInvalidations}:
 inserting f(::Float64) in Main at REPL[9]:1 invalidated:
   backedges: 1: superseding f(::Real) in Main at REPL[2]:1 with MethodInstance for f(::Float64) (2 children)
              2: superseding f(::Real) in Main at REPL[2]:1 with MethodInstance for f(::AbstractFloat) (2 children)
   1 mt_cache</code></pre><p>The output, <code>trees</code>, is a vector of <code>MethodInvalidations</code>, a data type defined in <code>SnoopCompile</code>; each of these is the set of invalidations triggered by a particular method definition. In this case, we only defined one method, so we can get at most one <code>MethodInvalidation</code>. <code>@snoopr using SomePkg</code> might result in a list of such objects, each connected to a particular method defined in a particular package (either <code>SomePkg</code> itself or one of its dependencies).</p><p>In this case, &quot;<code>inserting f(::Float64)</code>&quot; indicates that we added a method with signature <code>f(::Float64)</code>, and that this method triggered invalidations. (Invalidations can also be triggered by method deletion, although this should not happen in typical usage.) Next, notice the <code>backedges</code> line, and the fact that there are two items listed for it. This indicates that there were two proximal triggers for the invalidation, both of which superseded the method <code>f(::Real)</code>. One of these had been compiled specifically for <code>Float64</code>, due to our <code>call2f(c64)</code>. The other had been compiled specifically for <code>AbstractFloat</code>, due to our <code>call2f(cabs)</code>.</p><p>You can look at these invalidation trees in greater detail:</p><pre><code class="language-julia-repl">julia&gt; method_invalidations = trees[1];    # invalidations stemming from a single method

julia&gt; root = method_invalidations.backedges[1]  # get the first triggered invalidation
MethodInstance for f(::Float64) at depth 0 with 2 children

julia&gt; show(root)
MethodInstance for f(::Float64) (2 children)
 MethodInstance for callf(::Vector{Float64}) (1 children)
 ⋮

julia&gt; show(root; minchildren=0)
MethodInstance for f(::Float64) (2 children)
 MethodInstance for callf(::Vector{Float64}) (1 children)
  MethodInstance for call2f(::Vector{Float64}) (0 children)</code></pre><p>The indentation here reveals that <code>call2f</code> called <code>callf</code> which called <code>f</code>, and shows the entire &quot;chain&quot; of invalidations triggered by this method definition. Examining <code>root2 = method_invalidations.backedges[2]</code> yields similar results, but for <code>Vector{AbstractFloat}</code>.</p><h3 id="mt_backedges-invalidations"><a class="docs-heading-anchor" href="#mt_backedges-invalidations"><code>mt_backedges</code> invalidations</a><a id="mt_backedges-invalidations-1"></a><a class="docs-heading-anchor-permalink" href="#mt_backedges-invalidations" title="Permalink"></a></h3><p><code>MethodInvalidations</code> can have a second field, <code>mt_backedges</code>. These are invalidations triggered via the <code>MethodTable</code> for a particular function. When extracting <code>mt_backedges</code>, in addition to a root <code>MethodInstance</code> these also indicate a particular signature that triggered the invalidation. We can illustrate this by returning to the <code>call2f</code> example above:</p><pre><code class="language-julia-repl">julia&gt; call2f([&quot;hello&quot;])
ERROR: MethodError: no method matching f(::String)
[...]

julia&gt; invalidations = @snoopr f(::AbstractString) = 2;

julia&gt; trees = invalidation_trees(invalidations)
1-element Vector{SnoopCompile.MethodInvalidations}:
 inserting f(::AbstractString) in Main at REPL[6]:1 invalidated:
   mt_backedges: 1: signature Tuple{typeof(f), String} triggered MethodInstance for callf(::Vector{String}) (1 children)


julia&gt; sig, root = trees[1].mt_backedges[end];

julia&gt; sig
Tuple{typeof(f), String}

julia&gt; root
MethodInstance for callf(::Vector{String}) at depth 0 with 1 children</code></pre><p>You can see that the invalidating signature, <code>f(::String)</code>, is more specific than the signature of the defined method, but that it is what was minimally needed by <code>callf(::Vector{String})</code>.</p><p><code>mt_backedges</code> invalidations often reflect &quot;unhandled&quot; conditions in methods that have already been compiled.</p><h3 id="A-more-complex-example"><a class="docs-heading-anchor" href="#A-more-complex-example">A more complex example</a><a id="A-more-complex-example-1"></a><a class="docs-heading-anchor-permalink" href="#A-more-complex-example" title="Permalink"></a></h3><p>The structure of these trees can be considerably more complicated. For example, if <code>callf</code> also got called by some other method, and that method had also been executed (forcing it to be compiled), then <code>callf</code> would have multiple children. This is often seen with more complex, real-world tests. As a medium-complexity example, try the following:</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Any demonstration involving real-world packages might be altered from what is shown here by new releases of the relevant packages.</p></div></div><pre><code class="language-julia">julia&gt; using Revise

julia&gt; using SnoopCompileCore

julia&gt; invalidations = @snoopr using FillArrays;

julia&gt; using SnoopCompile

julia&gt; trees = invalidation_trees(invalidations)
3-element Vector{SnoopCompile.MethodInvalidations}:
 inserting all(f::Function, x::FillArrays.AbstractFill) in FillArrays at /pathto/.julia/packages/FillArrays/NjFh2/src/FillArrays.jl:556 invalidated:
   backedges: 1: superseding all(f::Function, a::AbstractArray; dims) in Base at reducedim.jl:880 with MethodInstance for all(::Base.var&quot;#388#389&quot;{_A} where _A, ::AbstractArray) (3 children)
              2: superseding all(f, itr) in Base at reduce.jl:918 with MethodInstance for all(::Base.var&quot;#388#389&quot;{_A} where _A, ::Any) (3 children)

 inserting any(f::Function, x::FillArrays.AbstractFill) in FillArrays at /pathto/.julia/packages/FillArrays/NjFh2/src/FillArrays.jl:555 invalidated:
   backedges: 1: superseding any(f::Function, a::AbstractArray; dims) in Base at reducedim.jl:877 with MethodInstance for any(::typeof(ismissing), ::AbstractArray) (1 children)
              2: superseding any(f, itr) in Base at reduce.jl:871 with MethodInstance for any(::typeof(ismissing), ::Any) (1 children)
              3: superseding any(f, itr) in Base at reduce.jl:871 with MethodInstance for any(::LoweredCodeUtils.var&quot;#11#12&quot;{_A} where _A, ::Any) (2 children)
              4: superseding any(f::Function, a::AbstractArray; dims) in Base at reducedim.jl:877 with MethodInstance for any(::LoweredCodeUtils.var&quot;#11#12&quot;{_A} where _A, ::AbstractArray) (4 children)

 inserting broadcasted(::Base.Broadcast.DefaultArrayStyle{N}, op, r::FillArrays.AbstractFill{T,N,Axes} where Axes) where {T, N} in FillArrays at /pathto/.julia/packages/FillArrays/NjFh2/src/fillbroadcast.jl:8 invalidated:
   backedges: 1: superseding broadcasted(::S, f, args...) where S&lt;:Base.Broadcast.BroadcastStyle in Base.Broadcast at broadcast.jl:1265 with MethodInstance for broadcasted(::Base.Broadcast.BroadcastStyle, ::typeof(JuliaInterpreter._Typeof), ::Any) (1 children)
              2: superseding broadcasted(::S, f, args...) where S&lt;:Base.Broadcast.BroadcastStyle in Base.Broadcast at broadcast.jl:1265 with MethodInstance for broadcasted(::Base.Broadcast.BroadcastStyle, ::typeof(string), ::AbstractArray) (177 children)</code></pre><p>Your specific results may differ from this, depending on which version of Julia and of packages you are using. In this case, you can see that three methods (one for <code>all</code>, one for <code>any</code>, and one for <code>broadcasted</code>) triggered invalidations. Perusing this list, you can see that methods in <code>Base</code>, <code>LoweredCodeUtils</code>, and <code>JuliaInterpreter</code> (the latter two were loaded by <code>Revise</code>) got invalidated by methods defined in FillArrays.</p><p>The most consequential ones (the ones with the most children) are listed last, and should be where you direct your attention first. That last entry looks particularly problematic, so let&#39;s extract it:</p><pre><code class="language-julia">julia&gt; methinvs = trees[end];

julia&gt; root = methinvs.backedges[end]
MethodInstance for broadcasted(::Base.Broadcast.BroadcastStyle, ::typeof(string), ::AbstractArray) at depth 0 with 177 children

julia&gt; show(root; maxdepth=10)
MethodInstance for broadcasted(::Base.Broadcast.BroadcastStyle, ::typeof(string), ::AbstractArray) (177 children)
 MethodInstance for broadcasted(::typeof(string), ::AbstractArray) (176 children)
  MethodInstance for #unpack#104(::Bool, ::typeof(Pkg.PlatformEngines.unpack), ::String, ::String) (175 children)
   MethodInstance for (::Pkg.PlatformEngines.var&quot;#unpack##kw&quot;)(::NamedTuple{(:verbose,),Tuple{Bool}}, ::typeof(Pkg.PlatformEngines.unpack), ::String, ::String) (174 children)
    MethodInstance for #download_verify_unpack#109(::Nothing, ::Bool, ::Bool, ::Bool, ::Bool, ::typeof(Pkg.PlatformEngines.download_verify_unpack), ::String, ::Nothing, ::String) (165 children)
     MethodInstance for (::Pkg.PlatformEngines.var&quot;#download_verify_unpack##kw&quot;)(::NamedTuple{(:ignore_existence, :verbose),Tuple{Bool,Bool}}, ::typeof(Pkg.PlatformEngines.download_verify_unpack), ::String, ::Nothing, ::String) (33 children)
      MethodInstance for (::Pkg.Artifacts.var&quot;#39#40&quot;{Bool,String,Nothing})(::String) (32 children)
       MethodInstance for create_artifact(::Pkg.Artifacts.var&quot;#39#40&quot;{Bool,String,Nothing}) (31 children)
        MethodInstance for #download_artifact#38(::Bool, ::Bool, ::typeof(Pkg.Artifacts.download_artifact), ::Base.SHA1, ::String, ::Nothing) (30 children)
         MethodInstance for (::Pkg.Artifacts.var&quot;#download_artifact##kw&quot;)(::NamedTuple{(:verbose, :quiet_download),Tuple{Bool,Bool}}, ::typeof(Pkg.Artifacts.download_artifact), ::Base.SHA1, ::String, ::Nothing) (23 children)
          MethodInstance for (::Pkg.Artifacts.var&quot;#download_artifact##kw&quot;)(::NamedTuple{(:verbose, :quiet_download),Tuple{Bool,Bool}}, ::typeof(Pkg.Artifacts.download_artifact), ::Base.SHA1, ::String) (22 children)
          ⋮
        ⋮
     MethodInstance for (::Pkg.PlatformEngines.var&quot;#download_verify_unpack##kw&quot;)(::NamedTuple{(:ignore_existence,),Tuple{Bool}}, ::typeof(Pkg.PlatformEngines.download_verify_unpack), ::String, ::Nothing, ::String) (130 children)
      MethodInstance for (::Pkg.Types.var&quot;#94#97&quot;{Pkg.Types.Context,String,Pkg.Types.RegistrySpec})(::String) (116 children)
       MethodInstance for #mktempdir#21(::String, ::typeof(mktempdir), ::Pkg.Types.var&quot;#94#97&quot;{Pkg.Types.Context,String,Pkg.Types.RegistrySpec}, ::String) (115 children)
        MethodInstance for mktempdir(::Pkg.Types.var&quot;#94#97&quot;{Pkg.Types.Context,String,Pkg.Types.RegistrySpec}, ::String) (114 children)
         MethodInstance for mktempdir(::Pkg.Types.var&quot;#94#97&quot;{Pkg.Types.Context,String,Pkg.Types.RegistrySpec}) (113 children)
          MethodInstance for clone_or_cp_registries(::Pkg.Types.Context, ::Vector{Pkg.Types.RegistrySpec}, ::String) (112 children)
          ⋮
     ⋮
   ⋮</code></pre><p>Here you can see a much more complex branching structure. From this, you can see that methods in <code>Pkg</code> are the most significantly affected; you could expect that loading <code>FillArrays</code> might slow down your next <code>Pkg</code> operation (perhaps depending on which operation you choose) executed in this same session.</p><p>Again, if you&#39;re following along, it&#39;s possible that you&#39;ll see something quite different, if subsequent development has protected <code>Pkg</code> against this form of invalidation.</p><h2 id="Filtering-invalidations"><a class="docs-heading-anchor" href="#Filtering-invalidations">Filtering invalidations</a><a id="Filtering-invalidations-1"></a><a class="docs-heading-anchor-permalink" href="#Filtering-invalidations" title="Permalink"></a></h2><p>Some method definitions trigger widespread invalidation. If you don&#39;t have time to fix all of them, you might want to focus on a specific set of invalidations. For instance, you might be the author of <code>PkgA</code> and you&#39;ve noted that loading <code>PkgB</code> invalidates a lot of <code>PkgA</code>&#39;s code. In that case, you might want to find just those invalidations triggered in your package. You can find them with <a href="../reference/#SnoopCompile.filtermod"><code>filtermod</code></a>:</p><pre><code class="language-julia">trees = invalidation_trees(@snoopr using PkgB)
ftrees = filtermod(PkgA, trees)</code></pre><p><code>filtermod</code> only selects trees where the root method was defined in the specified module.</p><p>A more selective yet exhaustive tool is <a href="../reference/#SnoopCompile.findcaller"><code>findcaller</code></a>, which allows you to find the path through the trees to a particular method:</p><pre><code class="language-julia">m = @which f(data)                  # look for the &quot;path&quot; that invalidates this method
f(data)                             # run once to force compilation
using SnoopCompile
trees = invalidation_trees(@snoopr using SomePkg)
invs = findcaller(m, trees)         # select the branch that invalidated a compiled instance of `m`</code></pre><p>When you don&#39;t know which method to choose, but know an operation that got slowed down by loading <code>SomePkg</code>, you can use <code>@snoopi</code> to find methods that needed to be recompiled. See <a href="../reference/#SnoopCompile.findcaller"><code>findcaller</code></a> for further details.</p><h2 id="Fixing-invalidations"><a class="docs-heading-anchor" href="#Fixing-invalidations">Fixing invalidations</a><a id="Fixing-invalidations-1"></a><a class="docs-heading-anchor-permalink" href="#Fixing-invalidations" title="Permalink"></a></h2><p>In addition to the text below, there is a <a href="https://www.youtube.com/watch?v=7VbXbI6OmYo">video</a> illustrating many of the same package features. The video also walks through a real-world example fixing invalidations that stemmed from inference problems in some of <code>Pkg</code>&#39;s code.</p><h3 id="ascend"><a class="docs-heading-anchor" href="#ascend">ascend</a><a id="ascend-1"></a><a class="docs-heading-anchor-permalink" href="#ascend" title="Permalink"></a></h3><p>SnoopCompile, partnering with the remarkable <a href="https://github.com/JuliaDebug/Cthulhu.jl">Cthulhu</a>, provides a tool called <code>ascend</code> to simplify diagnosing and fixing invalidations. To demonstrate this tool, let&#39;s use it on our test methods defined above. For best results, you&#39;ll want to copy those method definitions into a file:</p><pre><code class="language-julia">f(::Real) = 1
callf(container) = f(container[1])
call2f(container) = callf(container)

c64  = [1.0]; c32 = [1.0f0]; cabs = AbstractFloat[1.0];
call2f(c64)
call2f(c32)
call2f(cabs)

using SnoopCompileCore
invalidations = @snoopr f(::Float64) = 2
using SnoopCompile
trees = invalidation_trees(invalidations)
method_invalidations = trees[1]</code></pre><p>and <code>include</code> it into a fresh session.  (The full functionality of <code>ascend</code> doesn&#39;t work for methods defined at the REPL, but does if the methods are defined in a file.) In this demo, I called that file <code>/tmp/snoopr.jl</code>.</p><p>We start with</p><pre><code class="language-julia">julia&gt; root = method_invalidations.backedges[end]
MethodInstance for f(::AbstractFloat) at depth 0 with 2 children</code></pre><p>(It&#39;s common to start from the last element of <code>backedges</code> or <code>mt_backedges</code> since these have the largest number of children and are therefore most consequential.) Then:</p><pre><code class="language-julia">julia&gt; ascend(root)
Choose a call for analysis (q to quit):
 &gt;   f(::AbstractFloat)
       callf(::Vector{AbstractFloat})
         call2f(::Vector{AbstractFloat})</code></pre><p>This is an interactive menu: press the down arrow to go down, the up arrow to go up, and <code>Enter</code> to select an item for more detailed analysis. In large trees, you may also want to &quot;fold&quot; nodes of the tree (collapsing it so that the children are no longer displayed), particularly if you are working your way through a long series of invalidations and want to hide ones you&#39;ve already dealt with. You toggle folding using the space bar, and folded nodes are printed with a <code>+</code> in front of them.</p><p>For example, if we press the down arrow once, we get</p><pre><code class="language-julia">julia&gt; ascend(root)
Choose a call for analysis (q to quit):
     f(::AbstractFloat)
 &gt;     callf(::Vector{AbstractFloat})
         call2f(::Vector{AbstractFloat})</code></pre><p>Now hit <code>Enter</code> to select it:</p><pre><code class="language-julia">Choose caller of MethodInstance for f(::AbstractFloat) or proceed to typed code:
 &gt; &quot;/tmp/snoopr.jl&quot;, callf: lines [2]
   Browse typed code</code></pre><p>This is showing you another menu, with only two options (a third is to go back by hitting <code>q</code>). The first entry shows you the option to open the &quot;offending&quot; source file in <code>callf</code> at the position of the call to the parent node of <code>callf</code>, which in this case is <code>f</code>. (Sometimes there will be more than one call to the parent within the method, in which case instead of showing <code>[1]</code> it might show <code>[1, 17, 39]</code> indicating each separate location.) Selecting this option, when available, is typically the best way to start because you can sometimes resolve the problem just by inspection of the source.</p><p>If you hit the down arrow</p><pre><code class="language-julia">Choose caller of MethodInstance for f(::AbstractFloat) or proceed to typed code:
   &quot;/tmp/snoopr.jl&quot;, callf: lines [2]
 &gt; Browse typed code</code></pre><p>and then hit <code>Enter</code>, this is what you see:</p><pre><code class="language-julia">│ ─ %-1  = invoke callf(::Vector{AbstractFloat})::Int64
Variables
  #self#::Core.Const(callf, false)
  container::Vector{AbstractFloat}

Body::Int64
    @ /tmp/snoopr.jl:2 within `callf&#39;
1 ─ %1 = Base.getindex(container, 1)::AbstractFloat
│   %2 = Main.f(%1)::Int64
└──      return %2

Select a call to descend into or ↩ to ascend. [q]uit. [b]ookmark.
Toggles: [o]ptimize, [w]arn, [d]ebuginfo, [s]yntax highlight for Source/LLVM/Native.
Show: [S]ource code, [A]ST, [L]LVM IR, [N]ative code
Advanced: dump [P]arams cache.

 • %1  = invoke getindex(::Vector{AbstractFloat},::Int64)::AbstractFloat
   %2  = call #f(::AbstractFloat)::Int64
   ↩</code></pre><p>This is output from Cthulhu, and you should see its documentation for more information. (See also <a href="https://www.youtube.com/watch?v=qf9oA09wxXY">this video</a>.) While it takes a bit of time to master Cthulhu, it is an exceptionally powerful tool for diagnosing and fixing inference issues.</p><h3 id="&quot;Dead-ends&quot;:-finding-runtime-callers-with-MethodAnalysis"><a class="docs-heading-anchor" href="#&quot;Dead-ends&quot;:-finding-runtime-callers-with-MethodAnalysis">&quot;Dead ends&quot;: finding runtime callers with MethodAnalysis</a><a id="&quot;Dead-ends&quot;:-finding-runtime-callers-with-MethodAnalysis-1"></a><a class="docs-heading-anchor-permalink" href="#&quot;Dead-ends&quot;:-finding-runtime-callers-with-MethodAnalysis" title="Permalink"></a></h3><p>When a call is made by runtime dispatch and the world of available methods to handle the call does not narrow the types beyond what is known to the caller, the call-chain terminates. Here is a real-world example (one that may already be &quot;fixed&quot; by the time you read this) from analyzing invalidations triggered by specializing <code>Base.unsafe_convert(::Type{Ptr{T}}, ::Base.RefValue{S})</code> for specific types <code>S</code> and <code>T</code>:</p><pre><code class="language-none">julia&gt; ascend(root)
Choose a call for analysis (q to quit):
 &gt;   unsafe_convert(::Type{Ptr{Nothing}}, ::Base.RefValue{_A} where _A)
       _show_default(::IOBuffer, ::Any)
         show_default(::IOBuffer, ::Function)
           show_function(::IOBuffer, ::Function, ::Bool)
             print(::IOBuffer, ::Function)
         show_default(::IOBuffer, ::ProcessFailedException)
           show(::IOBuffer, ::ProcessFailedException)
             print(::IOBuffer, ::ProcessFailedException)
         show_default(::IOBuffer, ::Sockets.IPAddr)
           show(::IOBuffer, ::Sockets.IPAddr)</code></pre><p>Unfortunately for our investigations, none of these &quot;top level&quot; callers have defined backedges. (Overall, it&#39;s very fortunate that they don&#39;t, in that runtime dispatch without backedges avoids any need to invalidate the caller; the alternative would be extremely long chains of completely unnecessary invalidation, which would have many undesirable consequences.)</p><p>If you want to fix such &quot;short chains&quot; of invalidation, one strategy is to identify callers by brute force search enabled by the <code>MethodAnalysis</code> package. For example, one can discover the caller of <code>show(::IOBuffer, ::Sockets.IPAddr)</code> with</p><pre><code class="language-julia">using MethodAnalysis       # best from a fresh Julia session
mis = methodinstances();   # collect all *existing* MethodInstances (any future compilation will be ignored)
# Create a predicate that finds these argument types
using Sockets
argmatch(typs) = length(typs) &gt;= 2 &amp;&amp; typs[1] === IOBuffer &amp;&amp; typs[2] === Sockets.IPAddr
# Find any callers
callers = findcallers(show, argmatch, mis)</code></pre><p>which yields a single hit in <code>print(::IOBuffer, ::IPAddr)</code>. This too lacks any backedges, so a second application <code>findcallers(print, argmatch, mis)</code> links to <code>print_to_string(::IPAddr)</code>. This MethodInstance has a backedge to <code>string(::IPAddr)</code>, which has backedges to the method <code>Distributed.connect_to_worker(host::AbstractString, port::Integer)</code>. A bit of digging shows that this calls <code>Sockets.getaddrinfo</code> to look up an IP address, and this is inferred to return an <code>IPAddr</code> but the concrete type is unknown. A potential fix for this situation is described below.</p><p>This does not always work; for example, trying something similar for <code>ProcessExitedException</code> fails, likely because the call was made with even less type information. We might be able to find it with a more general predicate, for example</p><pre><code class="language-none">argmatch(typs) = length(typs) &gt;= 2 &amp;&amp; typs[1] === IOBuffer &amp;&amp; ProcessExitedException &lt;: typs[2]</code></pre><p>but this returns a lot of candidates and it is difficult to guess which of these might be the culprit(s). Finally, <code>findcallers</code> only detects method calls that are &quot;hard-wired&quot; into type-inferred code; if the call we&#39;re seeking was made from toplevel, or if the function itself was a runtime variable, there is no hope that <code>findcallers</code> will detect it.</p><h3 id="Tips-for-fixing-invalidations"><a class="docs-heading-anchor" href="#Tips-for-fixing-invalidations">Tips for fixing invalidations</a><a id="Tips-for-fixing-invalidations-1"></a><a class="docs-heading-anchor-permalink" href="#Tips-for-fixing-invalidations" title="Permalink"></a></h3><p>Invalidations occur in situations like our <code>call2f(c64)</code> example, where we changed our mind about what value <code>f</code> should return for <code>Float64</code>. Julia could not have returned the newly-correct answer without recompiling the call chain.</p><p>Aside from cases like these, most invalidations occur whenever new types are introduced, and some methods were previously compiled for abstract types. In some cases, this is inevitable, and the resulting invalidations simply need to be accepted as a consequence of a dynamic, updateable language. (As recommended above, you can often minimize invalidations by loading all your code at the beginning of your session, before triggering the compilation of more methods.) However, in many circumstances an invalidation indicates an opportunity to improve code. In our first example, note that the call <code>call2f(c32)</code> did not get invalidated: this is because the compiler knew all the specific types, and new methods did not affect any of those types. The main tips for writing invalidation-resistant code are:</p><ul><li>use <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-abstract-container-1">concrete types</a> wherever possible</li><li>write inferrable code (be especially aware of <a href="https://github.com/JuliaLang/julia/issues/15276">julia issue 15276</a>)</li><li>don&#39;t engage in <a href="https://docs.julialang.org/en/v1/manual/style-guide/#Avoid-type-piracy-1">type-piracy</a> (our <code>c64</code> example is essentially like type-piracy, where we redefined behavior for a pre-existing type)</li></ul><p>Since these tips also improve performance and allow programs to behave more predictably, these guidelines are not intrusive. Indeed, searching for and eliminating invalidations can help you improve the quality of your code.</p><h4 id="Adding-type-annotations"><a class="docs-heading-anchor" href="#Adding-type-annotations">Adding type annotations</a><a id="Adding-type-annotations-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-type-annotations" title="Permalink"></a></h4><p>In cases where invalidations occur, but you can&#39;t use concrete types (there are indeed many valid uses of <code>Vector{Any}</code>), you can often prevent the invalidation using some additional knowledge. One common example is extracting information from an <a href="https://docs.julialang.org/en/v1/manual/networking-and-streams/#IO-Output-Contextual-Properties-1">IOContext</a> structure, which is roughly defined as</p><pre><code class="language-julia">struct IOContext{IO_t &lt;: IO} &lt;: AbstractPipe
    io::IO_t
    dict::ImmutableDict{Symbol, Any}
end</code></pre><p>There are good reasons to use a value-type of <code>Any</code>, but that makes it impossible for the compiler to infer the type of any object looked up in an IOContext. Fortunately, you can help! For example, the documentation specifies that the <code>:color</code> setting should be a <code>Bool</code>, and since it appears in documentation it&#39;s something we can safely enforce. Changing</p><pre><code class="language-none">iscolor = get(io, :color, false)</code></pre><p>to</p><pre><code class="language-none">iscolor = get(io, :color, false)::Bool     # assert that the rhs is Bool-valued</code></pre><p>will throw an error if it isn&#39;t a <code>Bool</code>, and this allows the compiler to take advantage of the type being known in subsequent operations.</p><p>We&#39;ve already seen another relevant example above, where <code>getaddrinfo(::AbstractString)</code> was inferred to return an <code>IPAddr</code>, which is an abstract type. Since there are only two such types supported by the Sockets library, one potential fix is to annotate the returned value from <code>getaddrinfo</code> to be <code>Union{IPv4,IPv6}</code>. This will allow Julia to <a href="https://julialang.org/blog/2018/08/union-splitting/">union-split</a> future operations made using the returned value.</p><p>Before turning to a more complex example, it&#39;s worth noting that this trick applied to field accesses of abstract types is often one of the simplest ways to fix widespread inference problems. This is such an important case that it is described in the section below.</p><p>As a more detailed example, suppose you&#39;re writing code that parses Julia&#39;s <code>Expr</code> type:</p><pre><code class="language-julia">julia&gt; ex = :(Array{Float32,3})
:(Array{Float32, 3})

julia&gt; dump(ex)
Expr
  head: Symbol curly
  args: Vector{Any(3,))
    1: Symbol Array
    2: Symbol Float32
    3: Int64 3</code></pre><p><code>ex.args</code> is a <code>Vector{Any}</code>. However, for a <code>:curly</code> expression only certain types will be found among the arguments; you could write key portions of your code as</p><pre><code class="language-julia">a = ex.args[2]
if a isa Symbol
    # inside this block, Julia knows `a` is a Symbol, and so methods called on `a` will be resistant to invalidation
    foo(a)
elseif a isa Expr &amp;&amp; length((a::Expr).args) &gt; 2
    a::Expr         # sometimes you have to help inference by adding a type-assert
    x = bar(a)      # `bar` is now resistant to invalidation
elseif a isa Integer
    # even though you&#39;ve not made this fully-inferrable, you&#39;ve at least reduced the scope for invalidations
    # by limiting the subset of `foobar` methods that might be called
    y = foobar(a)
end</code></pre><p>Other tricks include replacing broadcasting on <code>v::Vector{Any}</code> with <code>Base.mapany(f, v)</code>–<code>mapany</code> avoids trying to narrow the type of <code>f(v[i])</code> and just assumes it will be <code>Any</code>, thereby avoiding invalidations of many <code>convert</code> methods.</p><p>Adding type-assertions and fixing inference problems are the most common approaches for fixing invalidations. You can discover these manually, but using Cthulhu is highly recommended.</p><h4 id="Inferrable-field-access-for-abstract-types"><a class="docs-heading-anchor" href="#Inferrable-field-access-for-abstract-types">Inferrable field access for abstract types</a><a id="Inferrable-field-access-for-abstract-types-1"></a><a class="docs-heading-anchor-permalink" href="#Inferrable-field-access-for-abstract-types" title="Permalink"></a></h4><p>When invalidations happen for methods that manipulate fields of abstract types, often there is a simple solution: create an &quot;interface&quot; for the abstract type specifying that certain fields must have certain types. Here&#39;s an example:</p><pre><code class="language-none">abstract type AbstractDisplay end

struct Monitor &lt;: AbstractDisplay
    height::Int
    width::Int
    maker::String
end

struct Phone &lt;: AbstractDisplay
    height::Int
    width::Int
    maker::Symbol
end

function Base.show(@nospecialize(d::AbstractDisplay), x)
    str = string(x)
    w = d.width
    if length(str) &gt; w  # do we have to truncate to fit the display width?
        ...</code></pre><p>In this <code>show</code> method, we&#39;ve deliberately chosen to prevent specialization on the specific type of <code>AbstractDisplay</code> (to reduce the total number of times we have to compile this method). As a consequence, Julia&#39;s inference generally will not realize that <code>d.width</code> returns an <code>Int</code>–it might be able to discover that by exhaustively checking all subtypes, but if there are a lot of such subtypes then such checks would slow compilation considerably.</p><p>Fortunately, you can help by defining an interface for generic <code>AbstractDisplay</code> objects:</p><pre><code class="language-none">function Base.getproperty(d::AbstractDisplay, name::Symbol)
    if name === :height
        return getfield(d, :height)::Int
    elseif name === :width
        return getfield(d, :width)::Int
    elseif name === :maker
        return getfield(d, :maker)::Union{String,Symbol}
    end
    return getfield(d, name)
end</code></pre><p>Julia&#39;s <a href="https://en.wikipedia.org/wiki/Constant_folding">constant propagation</a> will ensure that most accesses of those fields will be determined at compile-time, so this simple change robustly fixes many inference problems.</p><h4 id="Handling-edge-cases"><a class="docs-heading-anchor" href="#Handling-edge-cases">Handling edge cases</a><a id="Handling-edge-cases-1"></a><a class="docs-heading-anchor-permalink" href="#Handling-edge-cases" title="Permalink"></a></h4><p>You can sometimes get invalidations from failing to handle &quot;formal&quot; possibilities. For example, operations with regular expressions might return a <code>Union{Nothing, RegexMatch}</code>. You can sometimes get poor type inference by writing code that fails to take account of the possibility that <code>nothing</code> might be returned. For example, a comprehension</p><pre><code class="language-julia">ms = [m.match for m in match.((rex,), my_strings)]</code></pre><p>might be replaced with</p><pre><code class="language-julia">ms = [m.match for m in match.((rex,), my_strings) if m !== nothing]</code></pre><p>and return a better-typed result.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« Tutorial on the foundations</a><a class="docs-footer-nextpage" href="../snoopi_deep/">Snooping on inference: <code>@snoopi_deep</code> »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 5 January 2021 12:00">Tuesday 5 January 2021</span>. Using Julia version 1.7.0-DEV.213.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
